C51 COMPILER V9.51   MAIN                                                                  12/22/2014 11:48:41 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE Main.c BROWSE INCDIR(..\Library) DEBUG OBJECTEXTEND TAB
                    -S(3)

line level    source

   1          /*---------------------------------------------------
   2             main.c (v1.00)
   3             
   4             DDC-Z program, for electrocar, with ID card.
   5          ----------------------------------------------------*/
   6          
   7          //µç¶¯³µ
   8          #include "Main.h"
   9          #include "port.h"
  10          
  11          #include "AD.h"
  12          #include "voice.h"
  13          #include "pwm.h"
  14          #include "Timer.h"
  15          #include "Delay.h"
  16          #include "communication.h"
  17          #include "Battery.h"
  18          #include "Other.h"
  19          #include "operation.h"
  20          #include "UART.h"
  21                                                  
  22          /*------- Public variable declarations --------------------------*/
  23          extern tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;
  24          
  25          // ------ Private variable definitions -----------------------------
  26          bit stolen_alarm_flag = 0;             // when host been touch 3 times, this flag 1 before alarm voice present, no
             -t to detect sensor for 1st voice alarm.
  27          bit position_sensor_EN=0;        //Î»ÖÃ´«¸ÐÆ÷£¬¼´µ¹µØÌ§Æð´«¸ÐÆ÷×Ü¿ª¹Ø£¬1µÄÊ±ºò£¬¼ì²âÕâÁ½¸ö´«¸ÐÆ÷
  28          bit host_stolen_alarm1_EN = 0;      //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒôÊ¹ÄÜ
  29          bit host_stolen_alarm2_EN = 0;      //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶þ¶ÎÓïÒôÊ¹ÄÜ
  30          tByte host_stolen_alarm1_count = 0;    //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒô´ÎÊý
  31          tByte host_stolen_alarm2_count = 0;    //ÅÐ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶þ¶ÎÓïÒô´ÎÊý
  32          bit fell_flag=0;                 //ÅÐ¶ÏÖ÷»úµ¹ÏÂºó£¬ÖÃ1
  33          bit raised_flag=0;               //ÅÐ¶ÏÖ÷»ú±»Ì§Æðºó£¬ÖÃ1
  34          tByte sensor_2ndstage_count = 0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶Î¼ì²âÊ±£¬¼ÆËãµÍµçÆ½µÄÊ±¼ä
  35          tWord sensor_3rdstage_time = 0;        //´«¸ÐÆ÷½øÈëµÚÈý½×¶ÎµÄÊ±¼ä£¬
  36          tByte sensor_3rdstage_effcount = 0;    //´«¸ÐÆ÷½øÈëµÚÈý½×¶Îºó£¬ÓÐÐ§´¥Åö´ÎÊýµÄ¼ÆÊý
  37          tByte sensor_3rdstage_count = 0;       //´«¸ÐÆ÷½øÈëµÚÈý½×¶Îºó£¬µÍµçÆ½µÄ¼ÆÊý
  38          tWord sensor_3rdstage_interval = 0;    //´«¸ÐÆ÷ÔÚµÚÈý½×¶ÎÖÐ£¬Ã¿´ÎÓÐÐ§µÍµçÆ½¼ÆÊýÖ®¼äµÄÊ±¼ä¼ä¸ô¡£ÔÚÕâÆÚ¼äµÄµÍµ
             -çÆ½²»ÈÏÎªÓÐÐ§¡£
  39          bit raised_fell_flag = 0;              //µ¹µØ»òÕßÌ§Æð´¥·¢ºó£¬´Ë±êÖ¾Î»ÖÃ1
  40          tByte sensor_trigger_count=0;    //´«¸ÐÆ÷´¥·¢¼ÆÊý
  41          tWord sensor_2ndstage_time=0;    //´«¸ÐÆ÷½øÈëµÚ¶þ½×¶ÎºóÁ÷ÊÅÊ±¼äµÄ¼ÆÊý
  42          tByte sensor_1ststage_count=0;   //´«¸ÐÆ÷µÚÒ»½×¶ÎÅÐ¶ÏµÍµçÆ½µÄ¼ÆÊý
  43          tByte nearby_away_interval = 0;     //¸½»úÀë¿ªºÍ¿¿½üÊ±£¬ÓïÒôÌáÊ¾ºÍ¿ª¹ØËøµÄÊ±¼ä¼ä¸ô
  44          
  45          tByte raised_alarm_count = 0;    //Ö÷»ú±»Ì§Æðºó£¬Ïò¸½»ú·¢³ö±¨¾¯ÐÅºÅµÄ´ÎÊý
  46          tByte fell_alarm_count=0;        //Ö÷»úµ¹µØºó£¬Ïò¸½»ú·¢³ö±¨¾¯ÐÅºÅµÄ´ÎÊý
  47          tWord timer0_count=0;      // counter for timer0, increment every ticket         
  48          tByte received_data_buffer[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};     //½ÓÊÕÊý¾Ý»º´æ
  49          bit receive_data_finished_flag = 0;    //½ÓÊÕÕâÒ»´®Êý¾ÝÍê³Éºó£¬´Ë±êÖ¾Î»ÖÃ1
  50          tByte data_count = 0;            //½ÓÊÕÊý¾Ý»º´æµÄÎ»Êý£¬¼´±íÃ÷µÚ¼¸¸ö»º´æÊý¾Ý
  51          tByte one_receive_byte = 0;      //½ÓÊÕÊý¾ÝµÄÒ»¸ö×Ö½Ú£¬½ÓÊÕÍêºó½«Æä¸³Öµ¸øreceived_data_bufferÏà¶ÔÓ¦µÄ×Ö½Ú
  52          tByte one_receive_byte_count = 0;         //one_receive_byteÓÐ8Î»£¬´Ë¼ÆÊý±íÃ÷½ÓÊÕµ½µÚ¼¸Î»£¬Ã¿´Î¼ÆÊýµ½8µÄÊ±ºò±íÃ÷
C51 COMPILER V9.51   MAIN                                                                  12/22/2014 11:48:41 PAGE 2   

             -Ò»¸ö×Ö½Ú½ÓÊÕÍê³É¡£
  53          bit receive_wire_flag = 1;    //½ÓÊÕÍ¨ÐÅÏßµÄ±êÖ¾Î»£¬1±íÃ÷¸ßµçÆ½£¬0±íÃ÷µÍµçÆ½£¬Ã¿´Îtimer1Òç³öÊ±£¬ÅÐ¶ÏP1.1Ò»´Î
             -¡£ÒÔ´ËÀ´±íÃ÷ÊÇ·ñÎªÒ»´ÎÕýÈ·µÄÏÂ½µÑØ
  54          tByte receive_HV_count = 0;      //¶¨Ê±Æ÷T1ÔÚÃ»ÓÐÐÅºÅµ½À´µÄÊ±ºò£¬¶Ô¸ßµçÆ½¼ÆÊý£¬Ò»µ©³¬¹ýÄ³¸öÖµ£¬Ôò½«one_receive
             -_byte_countÇå0
  55          tByte receive_LV_count = 0;      //Ã¿´Îtimer1Òç³öÊ±ÅÐ¶Ï½ÓÊÕÏßÈç¹ûÎªLV£¬Ôò¼ÆÊý¼Ó1£¬ÒÔ´ËÀ´±íÃ÷µÍµçÆ½µÄÊ±¼ä
  56          tByte fell_wire_time=0;          //µ¹µØ¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  57          tByte raise_wire_time=0;         //Ì§Æð¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  58          tWord raised_fell_number = 0;          //µ¹µØ»òÕßÌ§Æð³ö·¢ºó£¬¼ÆÊý£¬µ½´ïÒ»¶¨ÊýÖµºó£¬½«ÆäÓë±êÖ¾Î»Ò»ÆðÇåÁã¡£
  59          bit raised_fell_once_flag = 0;         //raised_fell_flagÊÇ·ñÔø¾­±êÖ¾¹ý£¬Èç¹û±êÖ¾¹ýÔòÖÃ1.È»ºóÖ÷»ú±»»Ö¸´µ¹µØ»òÕß»
             -Ö¸´Ì§ÆðÊ±£¬´Ë±êÖ¾Î»¸´Î»¡£
  60          tByte key_rotated_on_flag=0;        //µç¶¯³µ¿ªÆô¹Ø±Õ±êÖ¾Î»£¬1±íÊ¾µç¶¯³µ¿ªÆôÁË£¬0±íÊ¾µç¶¯³µ¹Ø±ÕÁË
  61          tWord ADC_check_result = 0;      //×÷ÎªAD¼ì²âÖµ
  62          tByte wire_broken_count = 0;     // ×÷Îª¶ÏÏßºóµÄÊ±¼ä¼ì²â
  63          bit battery_stolen_EN = 0;       // ×÷Îªµç³Ø±»µÁµÄÊ¹ÄÜ¶Ë
  64          tByte battery_stolen_count = 0;  // ×÷Îªµç³Ø±»µÁµÄ±¨¾¯´ÎÊý
  65          bit horizontal_vibration = 0;    // ±íÊ¾´¹Ö±´«¸ÐÆ÷ÔÚÕñ¶¯£¬´ËÊ±¾ÍËã¹ØÔ¿³×£¬Ò²²»ÄÜÖ´ÐÐ¹ØÔ¿³×µÄ²Ù×÷¡
  66          tWord horizontal_vibration_count = 0;  //´¹Ö±´«¸ÐÆ÷´¥·¢ºó£¬¶ÔÊ±¼ä½øÐÐ¼ÆÊý¡£
  67          bit vibration_flag = 0;
  68          tWord vibration_count = 0;
  69          bit wire_broken_flag = 0;        // ¼ô¶ÏËøÏßµÄ±êÖ¾Î»
  70          bit IDkey_flag = 0;        // µ±ID¿¨¿¿½üÊ±ÈÏÖ¤Í¨¹ýºóÖÃ1£¬
  71          tByte IDkey_count = 0;     // ID¿¨ÈÏÖ¤Í¨¹ýºó£¬¼ÆÊ±1·ÖÖÓ£¬Ê¹Ô¿³×ÄÜ×ª¶¯¡£
  72          bit sensor_EN = 0;
  73          tByte enable_sensor_delay_count = 0;      // ´«¸ÐÆ÷ÑÓ³ÙµÄÊ±¼ä
  74          bit sensor_3rdalarm_flag = 0;
  75          bit wheeled_flag = 0;
  76          tWord wheeled_count = 0;
  77          
  78          bit test_flag = 0;      // ÉèÖÃ²âÊÔ¿ªÊ¼µÄ±êÖ¾Î»
  79          
  80          /*------- Private variable declarations --------------------------*/
  81          
  82          void main()
  83             {
  84   1         ADC_check_result = 0x3FF;
  85   1         
  86   1         // initialize the magnet, 
  87   1         MagentControl_1 = 0;
  88   1         MagentControl_2 = 0;
  89   1         wire_broken = 1;
  90   1         
  91   1         InitUART();
  92   1         InitT0(1);
  93   1         
  94   1         TI = 0;
  95   1         RI = 0;
  96   1         ES = 1;
  97   1         ET0 = 1;
  98   1         PS = 1;
  99   1         EA = 1;
 100   1      
 101   1         P10=1;
 102   1         
 103   1         lock_code = 1;
 104   1         
 105   1         // ³õÊ¼»¯Íê±Ïºó£¬¿ªÊ¼²âÊÔ³ÌÐò
 106   1         test_flag = 1;
 107   1         TR0 = 1;
 108   1            
 109   1         while(1)
 110   1            {        
C51 COMPILER V9.51   MAIN                                                                  12/22/2014 11:48:41 PAGE 3   

 111   2            sEOS_Go_To_Sleep();
 112   2            }
 113   1         }
 114          
 115          /*------------------------------------------------------------------
 116             timerT0()
 117             operation every ticket.
 118          --------------------------------------------------------------------*/
 119          
 120          void timer0() interrupt interrupt_timer_0_overflow
 121             {
 122   1         // manually reload timer0 configuration
 123   1         TH0 = timer0_8H;
 124   1         TL0 = timer0_8L;
 125   1         
 126   1         // timer0 is 1ms ticket, count the time flow of timer0, then operate every 2s.
 127   1         if(++timer0_count >= 3000)
 128   1            {
 129   2            // reset timer0 ticket counter every 2s
 130   2            timer0_count=0;
 131   2            
 132   2            if(test_flag == 1)
 133   2               {
 134   3               // ¿ªËø
 135   3               magnet_CW(5000, 1800, 42);
 136   3               Delay(40);
 137   3      
 138   3               // ·¢±¨¾¯ÐÅºÅ³öÈ¥
 139   3               ComMode_Data(ComMode_3, 28);
 140   3               // ¼ì²âADCµÄµçÑ¹Öµ
 141   3               ADC_check_result = GetADCResult(6); 
 142   3               
 143   3               // ·¢±¨¾¯ÐÅºÅ³öÈ¥
 144   3               ComMode_Data(ComMode_3, 28);        // ¹ØËø
 145   3               magnet_ACW(5000, 1800);
 146   3               Delay(40);
 147   3               // ·¢±¨¾¯ÐÅºÅ³öÈ¥
 148   3               ComMode_Data(ComMode_3, 28);        
 149   3               }
 150   2            }
 151   1      
 152   1      /* 
 153   1         // ¹ØÔ¿³×µÄ²Ù×÷£¬¼ì²âÊÇ·ñÓÐÂÖ×ÓÔÚ×ª¶¯
 154   1         if((key_rotate == 0)&&(key_rotated_on_flag == 1))
 155   1            {
 156   1            if((vibration_flag == 0)&&(wheeled_flag == 0))
 157   1               {
 158   1               Delay(5);
 159   1               if(key_rotate == 0)
 160   1                  {
 161   1                  // reset key rotation flag
 162   1                  key_rotated_on_flag=0;
 163   1                  
 164   1                  slave_away_speech(); 
 165   1                  }           
 166   1               }
 167   1            }
 168   1      
 169   1      
 170   1         // ²âÊÔÂÖ×ÓÔÚ×ª¶¯µÄÊ±ºò£¬²»ÄÜ¹ØËø
 171   1         if(wheeled_rotate == 1)
 172   1            {
C51 COMPILER V9.51   MAIN                                                                  12/22/2014 11:48:41 PAGE 4   

 173   1            wheeled_flag = 1;
 174   1            wheeled_count = 0;
 175   1            }
 176   1         if(wheeled_flag == 1)
 177   1            {
 178   1            if(++wheeled_count >= 2000)
 179   1               {
 180   1               wheeled_flag = 0;
 181   1               wheeled_count = 0;
 182   1                  }
 183   1            }
 184   1      
 185   1                              
 186   1         // ÄÃµôËø£¬Ä£ÄâÓÐÈË¼ô¶ÏËøÏß£¬²¥±¨ÓïÒô
 187   1         if(wire_broken == 0) 
 188   1            {
 189   1            battery_stolen_speech();
 190   1            }
 191   1      
 192   1         // ²âÊÔË®Òø¿ª¹Ø£¬µ¹µØ»òÕßÌ§Æðºó£¬²¥±¨ÓïÒô¡£
 193   1         if((raised_sensor_detect == 0)||(fell_sensor_detect == 0))
 194   1            {
 195   1            stolen_alarm_speech2();
 196   1            }
 197   1      
 198   1               
 199   1         // ²âÊÔÔÚÓÐµçÆ½µÄÇé¿öÏÂ£¬ÄÃµô48VµçÔ´£¬Ä£ÄâÓÐÈËÍµµçÆ¿µÄÇé¿ö£¬²¥±¨ÓïÒô
 200   1         if(ADC_check_result < 0x2c1)
 201   1            {
 202   1            battery_stolen_speech();
 203   1            }
 204   1      */
 205   1         }
 206          
 207          
 208          /*-----------------------------------------------
 209             ÓÃUART¶Ë¿Ú½ÓÊÕÊý¾Ý£¬9600²¨ÌØÂÊ£¬ÊÕµ½ºó±íÊ¾
 210             ÈÏÖ¤ÒÑÍ¨¹ý¡£
 211          -----------------------------------------------*/
 212          void uart_isr() interrupt 4 //ÖÐ¶Ï½ÓÊÕÊý¾Ý
 213             {
 214   1         if(RI)
 215   1            {
 216   2            RI=0;
 217   2      
 218   2            // assign one byte to buffer[i] 
 219   2            received_data_buffer[data_count] = SBUF;
 220   2            
 221   2            // judge whether buffer[0] is CmdHead
 222   2            if((data_count == 0) && (received_data_buffer[0] == IDkey0))
 223   2               {
 224   3               data_count = 1;
 225   3               }
 226   2            else if((data_count == 1) && (received_data_buffer[1] == IDkey1))
 227   2               {
 228   3               data_count = 2;
 229   3               }
 230   2            else if((data_count == 2) && (received_data_buffer[2] == IDkey2))
 231   2               {
 232   3               data_count = 3;
 233   3               }
 234   2            else if((data_count == 3) && (received_data_buffer[3] == IDkey3))
C51 COMPILER V9.51   MAIN                                                                  12/22/2014 11:48:41 PAGE 5   

 235   2               {
 236   3               data_count = 4;
 237   3               }
 238   2            else if((data_count == 4) && (received_data_buffer[4] == IDkey4))
 239   2               {
 240   3               data_count = 5;
 241   3               }
 242   2            else if((data_count == 5) && (received_data_buffer[5] == IDkey5))
 243   2               {
 244   3               data_count = 0;   
 245   3               IDkey_flag = 1;
 246   3               IDkey_count = 0;
 247   3               disable_sensor();
 248   3               }
 249   2            else 
 250   2               {
 251   3               data_count = 0;
 252   3               }
 253   2            }
 254   1         }
 255          
 256          
 257          /*---------------------------------------------------
 258             end of file
 259          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    371    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     19    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
