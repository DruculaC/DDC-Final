C51 COMPILER V9.51   MAIN                                                                  11/11/2014 13:53:27 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE Main.c BROWSE INCDIR(..\Library) DEBUG OBJECTEXTEND

line level    source

   1          /*---------------------------------------------------
   2                  main.c (v1.00)
   3                  
   4                  DDC-Z program, for electrocar, with ID card.
   5          ----------------------------------------------------*/
   6          
   7          //µÁ∂Ø≥µ
   8          #include "Main.h"
   9          #include "port.h"
  10          
  11          #include "AD.h"
  12          #include "voice.h"
  13          #include "pwm.h"
  14          #include "Timer.h"
  15          #include "Delay.h"
  16          #include "communication.h"
  17          #include "Battery.h"
  18          #include "Other.h"
  19          #include "operation.h"
  20          #include "UART.h"
  21                                                  
  22          /*------- Public variable declarations --------------------------*/
  23          extern tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;
  24          extern bit enable_sensor_delayEN;
  25          
  26          // ------ Private variable definitions -----------------------------
  27          bit stolen_alarm_flag = 0;                                      // when host been touch 3 times, this flag 1 before alarm voice present, no
             -t to detect sensor for 1st voice alarm.
  28          bit position_sensor_EN=0;               //Œª÷√¥´∏–∆˜£¨º¥µπµÿÃß∆¥´∏–∆˜◊‹ø™πÿ£¨1µƒ ±∫Ú£¨ºÏ≤‚’‚¡Ω∏ˆ¥´∏–∆˜
  29          bit host_stolen_alarm1_EN = 0;      //≈–∂œŒ™±ªµ¡±®æØ∫Ûµƒµ⁄“ª∂Œ”Ô“Ù πƒ‹
  30          bit host_stolen_alarm2_EN = 0;      //≈–∂œŒ™±ªµ¡±®æØ∫Ûµƒµ⁄∂˛∂Œ”Ô“Ù πƒ‹
  31          tByte host_stolen_alarm1_count = 0;             //≈–∂œŒ™±ªµ¡±®æØ∫Ûµƒµ⁄“ª∂Œ”Ô“Ù¥Œ ˝
  32          tByte host_stolen_alarm2_count = 0;             //≈–∂œŒ™±ªµ¡±®æØ∫Ûµƒµ⁄∂˛∂Œ”Ô“Ù¥Œ ˝
  33          bit fell_flag=0;                                                //≈–∂œ÷˜ª˙µπœ¬∫Û£¨÷√1
  34          bit raised_flag=0;                                      //≈–∂œ÷˜ª˙±ªÃß∆∫Û£¨÷√1
  35          tByte sensor_2ndstage_count = 0;                //¥´∏–∆˜Ω¯»Îµ⁄∂˛Ω◊∂ŒºÏ≤‚ ±£¨º∆À„µÕµÁ∆Ωµƒ ±º‰
  36          tWord sensor_3rdstage_time = 0;                 //¥´∏–∆˜Ω¯»Îµ⁄»˝Ω◊∂Œµƒ ±º‰£¨
  37          tByte sensor_3rdstage_effcount = 0;             //¥´∏–∆˜Ω¯»Îµ⁄»˝Ω◊∂Œ∫Û£¨”––ß¥•≈ˆ¥Œ ˝µƒº∆ ˝
  38          tByte sensor_3rdstage_count = 0;                        //¥´∏–∆˜Ω¯»Îµ⁄»˝Ω◊∂Œ∫Û£¨µÕµÁ∆Ωµƒº∆ ˝
  39          tWord sensor_3rdstage_interval = 0;             //¥´∏–∆˜‘⁄µ⁄»˝Ω◊∂Œ÷–£¨√ø¥Œ”––ßµÕµÁ∆Ωº∆ ˝÷Æº‰µƒ ±º‰º‰∏Ù°£‘⁄’‚∆⁄º‰µƒµÕµ
             -Á∆Ω≤ª»œŒ™”––ß°£
  40          bit raised_fell_flag = 0;                                       //µπµÿªÚ’ﬂÃß∆¥•∑¢∫Û£¨¥À±Í÷æŒª÷√1
  41          tByte sensor_trigger_count=0;           //¥´∏–∆˜¥•∑¢º∆ ˝
  42          tWord sensor_2ndstage_time=0;           //¥´∏–∆˜Ω¯»Îµ⁄∂˛Ω◊∂Œ∫Û¡˜ ≈ ±º‰µƒº∆ ˝
  43          tByte sensor_1ststage_count=0;  //¥´∏–∆˜µ⁄“ªΩ◊∂Œ≈–∂œµÕµÁ∆Ωµƒº∆ ˝
  44          tByte nearby_away_interval = 0;         //∏Ωª˙¿Îø™∫ÕøøΩ¸ ±£¨”Ô“ÙÃ· æ∫Õø™πÿÀ¯µƒ ±º‰º‰∏Ù
  45          
  46          tByte raised_alarm_count = 0;    //÷˜ª˙±ªÃß∆∫Û£¨œÚ∏Ωª˙∑¢≥ˆ±®æØ–≈∫≈µƒ¥Œ ˝
  47          tByte fell_alarm_count=0;        //÷˜ª˙µπµÿ∫Û£¨œÚ∏Ωª˙∑¢≥ˆ±®æØ–≈∫≈µƒ¥Œ ˝
  48          tWord timer0_count=0;           // counter for timer0, increment every ticket                   
  49          tByte received_data_buffer[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};             //Ω” ’ ˝æ›ª∫¥Ê
  50          bit receive_data_finished_flag = 0;             //Ω” ’’‚“ª¥Æ ˝æ›ÕÍ≥…∫Û£¨¥À±Í÷æŒª÷√1
  51          tByte data_count = 0;                           //Ω” ’ ˝æ›ª∫¥ÊµƒŒª ˝£¨º¥±Ì√˜µ⁄º∏∏ˆª∫¥Ê ˝æ›
  52          tByte one_receive_byte = 0;             //Ω” ’ ˝æ›µƒ“ª∏ˆ◊÷Ω⁄£¨Ω” ’ÕÍ∫ÛΩ´∆‰∏≥÷µ∏¯received_data_bufferœ‡∂‘”¶µƒ◊÷Ω⁄
  53          tByte one_receive_byte_count = 0;                       //one_receive_byte”–8Œª£¨¥Àº∆ ˝±Ì√˜Ω” ’µΩµ⁄º∏Œª£¨√ø¥Œº∆ ˝µΩ8µƒ ±∫Ú±Ì√˜
C51 COMPILER V9.51   MAIN                                                                  11/11/2014 13:53:27 PAGE 2   

             -“ª∏ˆ◊÷Ω⁄Ω” ’ÕÍ≥…°£
  54          bit receive_wire_flag = 1;              //Ω” ’Õ®–≈œﬂµƒ±Í÷æŒª£¨1±Ì√˜∏ﬂµÁ∆Ω£¨0±Ì√˜µÕµÁ∆Ω£¨√ø¥Œtimer1“Á≥ˆ ±£¨≈–∂œP1.1“ª¥Œ
             -°£“‘¥À¿¥±Ì√˜ «∑ÒŒ™“ª¥Œ’˝»∑µƒœ¬Ωµ—ÿ
  55          tByte receive_HV_count = 0;             //∂® ±∆˜T1‘⁄√ª”––≈∫≈µΩ¿¥µƒ ±∫Ú£¨∂‘∏ﬂµÁ∆Ωº∆ ˝£¨“ªµ©≥¨π˝ƒ≥∏ˆ÷µ£¨‘ÚΩ´one_receive
             -_byte_count«Â0
  56          tByte receive_LV_count = 0;             //√ø¥Œtimer1“Á≥ˆ ±≈–∂œΩ” ’œﬂ»Áπ˚Œ™LV£¨‘Úº∆ ˝º”1£¨“‘¥À¿¥±Ì√˜µÕµÁ∆Ωµƒ ±º‰
  57          tByte fell_wire_time=0;          //µπµÿºÏ≤‚œﬂ£¨ºÏ≤‚µÕµÁ∆Ωµƒ ±º‰
  58          tByte raise_wire_time=0;                        //Ãß∆ºÏ≤‚œﬂ£¨ºÏ≤‚µÕµÁ∆Ωµƒ ±º‰
  59          tWord raised_fell_number = 0;                           //µπµÿªÚ’ﬂÃß∆≥ˆ∑¢∫Û£¨º∆ ˝£¨µΩ¥Ô“ª∂® ˝÷µ∫Û£¨Ω´∆‰”Î±Í÷æŒª“ª∆«Â¡„°£
  60          bit raised_fell_once_flag = 0;                  //raised_fell_flag «∑Ò‘¯æ≠±Í÷æπ˝£¨»Áπ˚±Í÷æπ˝‘Ú÷√1.»ª∫Û÷˜ª˙±ªª÷∏¥µπµÿªÚ’ﬂª
             -÷∏¥Ãß∆ ±£¨¥À±Í÷æŒª∏¥Œª°£
  61          tByte key_rotated_on_flag=0;                    //µÁ∂Ø≥µø™∆Ùπÿ±’±Í÷æŒª£¨1±Ì æµÁ∂Ø≥µø™∆Ù¡À£¨0±Ì æµÁ∂Ø≥µπÿ±’¡À
  62          tWord ADC_check_result = 0;             //◊˜Œ™ADºÏ≤‚÷µ
  63          tByte wire_broken_count = 0;            // ◊˜Œ™∂œœﬂ∫Ûµƒ ±º‰ºÏ≤‚
  64          bit battery_stolen_EN = 0;                      // ◊˜Œ™µÁ≥ÿ±ªµ¡µƒ πƒ‹∂À
  65          tByte battery_stolen_count = 0; // ◊˜Œ™µÁ≥ÿ±ªµ¡µƒ±®æØ¥Œ ˝
  66          bit horizontal_vibration = 0;           // ±Ì æ¥π÷±¥´∏–∆˜‘⁄’Ò∂Ø£¨¥À ±æÕÀ„πÿ‘ø≥◊£¨“≤≤ªƒ‹÷¥––πÿ‘ø≥◊µƒ≤Ÿ◊˜°
  67          tWord horizontal_vibration_count = 0;   //¥π÷±¥´∏–∆˜¥•∑¢∫Û£¨∂‘ ±º‰Ω¯––º∆ ˝°£
  68          bit vibration_flag = 0;
  69          tWord vibration_count = 0;
  70          bit wire_broken_flag = 0;                       // ºÙ∂œÀ¯œﬂµƒ±Í÷æŒª
  71          tByte IDkey5 = IDkey0^IDkey1^IDkey2^IDkey3^IDkey4;              // ”…«∞5Œª√‹¬Î◊È≥…µƒ“ÏªÚ
  72          bit IDkey_flag = 0;                     // µ±IDø®øøΩ¸ ±»œ÷§Õ®π˝∫Û÷√1£¨
  73          tByte IDkey_count = 0;          // IDø®»œ÷§Õ®π˝∫Û£¨º∆ ±1∑÷÷”£¨ π‘ø≥◊ƒ‹◊™∂Ø°£
  74          bit sensor_EN = 0;
  75          tByte enable_sensor_delay_count = 0;            // ¥´∏–∆˜—”≥Ÿµƒ ±º‰
  76          bit sensor_3rdalarm_flag = 0;
  77          bit wheeled_flag = 0;
  78          tWord wheeled_count = 0;
  79          
  80          bit test_flag = 0;              // …Ë÷√≤‚ ‘ø™ ºµƒ±Í÷æŒª
  81          
  82          /*------- Private variable declarations --------------------------*/
  83          
  84          void main()
  85                  {
  86   1              InitUART();
  87   1              InitT0(1);
  88   1              
  89   1              TI = 0;
  90   1              RI = 0;
  91   1              ES = 1;
  92   1              ET0 = 1;
  93   1              PS = 1;
  94   1              EA = 1;
  95   1      
  96   1              P10 = 1;
  97   1              
  98   1              transmiter_EN = 0;
  99   1              // ≥ı ºªØÕÍ±œ∫Û£¨ø™ º≤‚ ‘≥Ã–Ú
 100   1              test_flag = 1;
 101   1              
 102   1              ADC_check_result = 0x3FF;
 103   1              
 104   1              while(1)
 105   1                      {        
 106   2                      sEOS_Go_To_Sleep();
 107   2                      }
 108   1              }
 109          
 110          /*------------------------------------------------------------------
 111                  timerT0()
C51 COMPILER V9.51   MAIN                                                                  11/11/2014 13:53:27 PAGE 3   

 112                  operation every ticket.
 113          --------------------------------------------------------------------*/
 114          
 115          void timer0() interrupt interrupt_timer_0_overflow
 116                  {
 117   1              // manually reload timer0 configuration
 118   1              TH0 = timer0_8H;
 119   1              TL0 = timer0_8L;
 120   1              
 121   1              // timer0 is 1ms ticket, count the time flow of timer0, then operate every 2s.
 122   1              if(++timer0_count >= 3000)
 123   1                      {
 124   2                      // reset timer0 ticket counter every 2s
 125   2                      timer0_count=0;
 126   2                      
 127   2                      if(test_flag == 1)
 128   2                              {
 129   3                              ComMode_Data(ComMode_1, 42);
 130   3                              }
 131   2                      }
 132   1              }
 133          
 134          /*-----------------------------------------------
 135                  ”√UART∂Àø⁄Ω” ’ ˝æ›£¨9600≤®Ãÿ¬ £¨ ’µΩ∫Û±Ì æ
 136                  »œ÷§“—Õ®π˝°£
 137          -----------------------------------------------*/
 138          void uart_isr() interrupt 4 //÷–∂œΩ” ’ ˝æ›
 139                  {
 140   1              if(RI)
 141   1                      {
 142   2                      RI=0;
 143   2      
 144   2                      // assign one byte to buffer[i] 
 145   2                      received_data_buffer[data_count] = SBUF;
 146   2                      
 147   2                      // judge whether buffer[0] is CmdHead
 148   2                      if((data_count == 0) && (received_data_buffer[0] == IDkey0))
 149   2                              {
 150   3                              data_count = 1;
 151   3                              }
 152   2                      else if((data_count == 1) && (received_data_buffer[1] == IDkey1))
 153   2                              {
 154   3                              data_count = 2;
 155   3                              }
 156   2                      else if((data_count == 2) && (received_data_buffer[2] == IDkey2))
 157   2                              {
 158   3                              data_count = 3;
 159   3                              }
 160   2                      else if((data_count == 3) && (received_data_buffer[3] == IDkey3))
 161   2                              {
 162   3                              data_count = 4;
 163   3                              }
 164   2                      else if((data_count == 4) && (received_data_buffer[4] == IDkey4))
 165   2                              {
 166   3                              data_count = 5;
 167   3                              }
 168   2                      else if((data_count == 5) && (received_data_buffer[5] == IDkey5))
 169   2                              {
 170   3                              data_count = 0; 
 171   3                              IDkey_flag = 1;
 172   3                              IDkey_count = 0;
 173   3                              disable_sensor();
C51 COMPILER V9.51   MAIN                                                                  11/11/2014 13:53:27 PAGE 4   

 174   3                              }
 175   2                      else 
 176   2                              {
 177   3                              data_count = 0;
 178   3                              }
 179   2                      }
 180   1              }
 181          
 182          
 183          /*---------------------------------------------------
 184                  end of file
 185          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    299    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     48    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     19    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
